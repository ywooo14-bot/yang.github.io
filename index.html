<!doctype html>
<html lang="zh-CN">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>作品集</title>

  <!-- favicon（来自 favicon_io 文件夹）-->
  <link rel="apple-touch-icon" sizes="180x180" href="favicon_io/apple-touch-icon.png">
  <link rel="icon" type="image/png" sizes="32x32" href="favicon_io/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="16x16" href="favicon_io/favicon-16x16.png">
  <link rel="manifest" href="favicon_io/site.webmanifest">
  <meta name="theme-color" content="#1C1C1C">

  <style>
    :root {
      --bg: #1C1C1C;
      --white20: rgba(255,255,255,0.20); /* 骨架颜色 20% 白色 */
      --white: #FFFFFF;
    }
    html,body{
      margin:0;
      padding:0;
      height:100%;
      background:var(--bg);
      color:var(--white);
      -webkit-font-smoothing:antialiased;
      -moz-osx-font-smoothing:grayscale;
      font-family: system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", "Noto Sans", "PingFang SC", "Hiragino Sans GB", "Microsoft Yahei", sans-serif;
      user-select: none; /* 禁止选中文字 */
    }

    /* 页面容器：手机 100% 宽度；桌面宽度 65%，最大1200 */
    .wrap {
      box-sizing: border-box;
      padding-top: 60px; /* 内容区顶部60 */
      display:flex;
      justify-content:center;
      align-items:flex-start;
      width:100%;
      min-height:100vh;
    }
    .content {
      width: 100%;
      max-width: 1200px;
      /* 桌面占比 65%：
         使用媒体查询在大屏时限制为 65% 宽度的容器，再由 max-width 限制 */
    }
    @media(min-width: 900px){
      .content {
        width: 65vw; /* 65% 视口宽度 */
        max-width: 1200px;
      }
    }

    /* 图片栈：一列展示，间距0 */
    .stack {
      display:flex;
      flex-direction:column;
      gap:0;
      margin:0;
      padding:0;
    }

    /* 单张项：使用背景图填充（防止直接右键图片另存为） */
    .item {
      width:100%;
      position:relative;
      overflow:hidden;
      background-color: #000;
      background-position:center;
      background-size:cover; /* Fill */
      min-height: 1080px; /* 如果图片比 1080 小，会被拉伸成 Fill；按需求可调整 */
      -webkit-user-drag: none;
      user-select: none;
    }

    /* 骨架图：宽度和图片一致，高度1080，颜色FFFFFF 20% */
    .skeleton {
      width:100%;
      height:1080px;
      background: var(--white20);
      display:block;
      transition:opacity .3s ease;
    }

    /* 一个透明遮罩，阻止长按/右键直接保存 */
    .blocker {
      position:absolute;
      left:0;
      right:0;
      top:0;
      bottom:0;
      z-index:5;
      /* pointer-events: auto; 保持可以阻止默认行为 */
    }

    /* 网络异常覆盖提示 */
    .error-overlay {
      position: fixed;
      inset: 0;
      display:flex;
      align-items:center;
      justify-content:center;
      background: rgba(0,0,0,0.6);
      z-index:9999;
      color: var(--white);
      text-align:center;
      padding: 20px;
    }
    .error-box {
      background: transparent;
      border-radius: 8px;
      padding: 18px;
      display:inline-block;
    }
    .error-box p {
      margin:0 0 20px 0;
      font-size:16px;
      color: var(--white);
    }
    .reload-btn {
      display:inline-flex;
      align-items:center;
      justify-content:center;
      width:96px;
      height:36px;
      border-radius:4px;
      border: none;
      background: var(--white);
      color: var(--bg);
      font-size:14px;
      cursor:pointer;
    }

    /* 细节：禁用图片拖拽的 pointer 事件 */
    img.protect {
      -webkit-user-drag:none;
      user-drag:none;
      user-select: none;
      pointer-events: none;
      width:100%;
      height:100%;
      object-fit:cover;
    }

    /* 无障碍/屏幕阅读器隐藏提示 */
    .sr-only {
      position:absolute;
      width:1px;height:1px;padding:0;margin:-1px;overflow:hidden;clip:rect(0,0,0,0);white-space:nowrap;border:0;
    }
  </style>
</head>
<body>
  <div class="wrap" id="wrap">
    <main class="content" id="content" role="main" aria-live="polite">
      <section class="stack" id="stack" aria-label="作品展示">
        <!-- JS 会把 .item（骨架或图片）插入到这里 -->
      </section>
    </main>
  </div>

  <!-- 网络异常提示（JS 根据情况显示/隐藏） -->
  <div id="errorOverlay" class="error-overlay" style="display:none;">
    <div class="error-box">
      <p>网络异常，请重新加载</p>
      <button class="reload-btn" id="reloadBtn">重新加载</button>
    </div>
  </div>

  <script>
    (function(){
      const stack = document.getElementById('stack');
      const errorOverlay = document.getElementById('errorOverlay');
      const reloadBtn = document.getElementById('reloadBtn');

      // 配置（按需修改）
      const IMG_FOLDER = 'images';
      const FNAME_PREFIX = 'work'; // work1.png、work2.png ...
      const FNAME_EXT = '.png';    // 如果你用jpg，改成 .jpg
      const MAX_TRIES = 100;       // 最多尝试到 work100（通常远大于实际数量）
      const STOP_AFTER_MISSES = 3; // 连续几张不存在就停止（避免浪费请求）

      // 当用户按下重新加载
      reloadBtn.addEventListener('click', () => location.reload());

      // 检测是否网络异常（尝试获取 favicon 或根目录小文件）
      function checkNetwork() {
        // 使用 fetch 检测网络连通性（不会受图片 404 干扰）
        return fetch('favicon_io/favicon-32x32.png', {method:'HEAD', cache:'no-store'})
          .then(resp => {
            if (!resp.ok) { // 404 也可能说明文件缺失，但网络正常
              return true; // 网络通了，但文件可能不在仓库里 —— 继续加载图片尝试
            }
            return true;
          })
          .catch(() => false);
      }

      // 禁用右键、长按、拖拽
      document.addEventListener('contextmenu', e => e.preventDefault());
      document.addEventListener('dragstart', e => e.preventDefault());
      document.addEventListener('selectstart', e => e.preventDefault());

      // 创建一个带骨架的 item 占位
      function makePlaceholder(index) {
        const item = document.createElement('div');
        item.className = 'item';
        item.dataset.index = index;
        const sk = document.createElement('div');
        sk.className = 'skeleton';
        sk.setAttribute('aria-hidden','true');
        item.appendChild(sk);

        // 添加遮罩阻止长按或保存
        const blocker = document.createElement('div');
        blocker.className = 'blocker';
        blocker.addEventListener('contextmenu', e => e.preventDefault());
        item.appendChild(blocker);

        return item;
      }

      // 加载单张图片（使用 Image 对象检测 onload / onerror）
      function loadImageToItem(index, itemEl) {
        return new Promise((resolve) => {
          const url = `${IMG_FOLDER}/${FNAME_PREFIX}${index}${FNAME_EXT}`;
          const img = new Image();
          img.crossOrigin = 'anonymous';
          img.onload = () => {
            // 使用背景图替换骨架（更难被直接右键保存）
            itemEl.style.backgroundImage = `url("${url}")`;
            // 移除 skeleton 子元素（可用淡入效果）
            const sk = itemEl.querySelector('.skeleton');
            if (sk) {
              sk.style.opacity = '0';
              setTimeout(() => sk.remove(), 300);
            }
            resolve({ok:true, index, url});
          };
          img.onerror = () => {
            resolve({ok:false, index, url});
          };
          // 开始加载（不等待全部完成再显示）
          img.src = url;
        });
      }

      // 主流程：检查网络 -> 顺序尝试加载 work1..workN（遇到连续 miss 停止）
      async function init() {
        const online = await checkNetwork();
        if (!online) {
          // 网络异常：显示覆盖提示
          errorOverlay.style.display = 'flex';
          return;
        }

        // 先插入若干个占位（为避免闪烁，初始插入较小数量；后续如果发现更多图片，会动态追加）
        // 为了体验，这里先插入 8 个占位（你当前有8张），但代码会继续尝试找更多。
        const initialPlaceholders = 8;
        for (let i=1;i<=initialPlaceholders;i++){
          stack.appendChild(makePlaceholder(i));
        }

        // 然后按序加载：从1到MAX_TRIES；遇到 STOP_AFTER_MISSES 个连续不存在则停止
        let misses = 0;
        let index = 1;
        // 保证 stack 中至少有占位：如果 index > initialPlaceholders，先追加占位
        while (index <= MAX_TRIES) {
          // 确保对应索引存在占位 DOM
          let existing = stack.querySelector(`.item[data-index="${index}"]`);
          if (!existing) {
            existing = makePlaceholder(index);
            stack.appendChild(existing);
          }
          // 开始加载这张图（并行进行：但循环控制继续与否取决于结果）
          // NOTE: We await here to detect miss/stop conditions in order.
          const res = await loadImageToItem(index, existing);
          if (res.ok) {
            misses = 0; // 重置连续缺失计数
          } else {
            // 如果图片不存在：移除对应 DOM（避免在页面中留下空白占位）
            // 但是要小心，如果是临时网络波动，可能把真实图片误判为不存在。
            // 因为我们已做网络在线检测，通常 onerror = 404（文件不存在）。
            existing.remove();
            misses++;
            // 如果连续缺失达到阈值，则停止尝试后续编号
            if (misses >= STOP_AFTER_MISSES) break;
          }
          index++;
        }

        // 到这里已尝试完毕；如果页面没有任何图片，给出友好提示
        if (!stack.children.length) {
          const box = document.createElement('div');
          box.style.padding = '60px';
          box.style.textAlign = 'center';
          box.innerHTML = `<p style="color:var(--white)">未找到任何作品图片。请将图片按 "work1.png, work2.png ..." 命名并上传到 /images 文件夹。</p>`;
          stack.appendChild(box);
        }
      }

      // 启动
      init();

      // 可选：监听在线状态变化（用户恢复网络时自动刷新）
      window.addEventListener('online', () => location.reload());
    })();
  </script>
</body>
</html>
